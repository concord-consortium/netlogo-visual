;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;; Data export functions to add to model ;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Structure definitions for setup-data-export method:
;;;
;;;
;;; ****** end of data-export methods
;;;
;;; Now add these calls to finish integrating the data-export functions:
;;;
;;; Put at beginning of Model:
;;;
;;;   __includes [ "data-export:inquiry.nls" ]
;;;
;;; Put at beginning of main model loop
;;;
;;;   setup-data-export
;;;
;;; Put in inner model loop after times series data are generated:
;;; argument example: time, data1, data2, ...
;;;
;;;   update-data-series ( list t x-dum v-dum )
;;;
;;; Put at exit (or exits) of model loop
;;; arguments include any local variables that are computational outputs
;;;
;;;    update-run-series [ a-max ]
;;;
;;; More Description ...
;;;

globals [
  data-export:module-available
  data-export:model-data
  data-export:data-available?
  data-export:data-ready?
  data-export:inquiry-summary
]

to data-export:initialize
  set data-export:module-available true
  set data-export:data-ready? false
  set data-export:data-available? false
  data-export:make-model-data
  data-export:init-inquiry-summary
end

to data-export:init-inquiry-summary
  set data-export:inquiry-summary ""        ; this will contain inquiry-summary data in a string form generated by the model from student actions after a run
end

;;;
;;; data-export:make-model-description
;;; Call this to generate the JSON data export
;;;
to data-export:make-model-data
  set data-export:data-ready? false
  set data-export:data-ready? false
  let temp ""
  set temp (word temp "{\n")
  set temp (word temp "  \"runs\": \"" data-export:inquiry-summary "\"\n")
  set temp (word temp "}\n")
  set data-export:model-data temp
  set data-export:data-ready? true
end

to data-export:update-inquiry-summary [ new-inquiry-summary ]
  ifelse is-string? new-inquiry-summary
    [ set data-export:inquiry-summary new-inquiry-summary ]
    [ set data-export:inquiry-summary ( word new-inquiry-summary ) ]
end

to-report data-export:section [ indent name keys categorical-keys dataset epilog]
  let indent1 data-export:indent-string indent
  let indent2 data-export:indent-string (indent + 2)
  let jsonstr ""
  let key-pairs [ ]
  set jsonstr data-export:json-line jsonstr indent ( list name ) ": [\n"
  if not empty? dataset [
    foreach but-last dataset [
      ifelse (item 1 ?) = "categorical" and not empty? categorical-keys
      [ set key-pairs data-export:create-keypairs categorical-keys ? ]
      [ set key-pairs data-export:create-keypairs keys ? ]
      set jsonstr ( word jsonstr indent2 data-export:json-object key-pairs ",\n") ]
    let last-data last dataset
    ifelse (item 1 last-data) = "categorical" and not empty? categorical-keys
    [ set key-pairs data-export:create-keypairs categorical-keys last-data ]
    [ set key-pairs data-export:create-keypairs keys last-data ]
    set jsonstr ( word jsonstr indent2 data-export:json-object key-pairs "\n") ]
  set jsonstr ( word jsonstr indent1 "]" epilog)
  report jsonstr
end

to-report data-export:json-line [ existing indent items suffix]
  let str ( word existing data-export:indent-string indent )
  set str ( word str reduce [ ( word ?1 ", " ?2 ) ] ( map data-export:jsonify-item items ) )
  set str ( word str suffix )
  report str
end

;;;
;;; General JSON Utilities
;;;
;;; *** data-export:json-object ***
;;;
;;; Converts lists to JSON objects in string form
;;;
;;; Examples:
;;;
;;;   data-export:json-object [ "size" 24 ]
;;;   => "{ \"size\":\"size\":24 }"
;;;
;;;   data-export:json-object [ [ "size" 24 ] [ "length" 18 ] ]
;;;   => "{ \"size\":24, \"length\":18 }"
;;;
;;;   data-export:json-object [ "description" [ "size" 24 ] ]
;;;   => "{ \"description\":{ \"size\":\"size\":24 }"
;;;
;;;   *** "{ \"description\":[[size 24], [length 18], [color red]] }"
;;;
;;;   data-export:json-object [ "ages" [ 24 32 18 44 ] ]
;;;   => "{ \"ages\":[24, 32, 18, 44] }""
;;;
;;;   data-export:json-object [ "values" [ "yes" "no" "maybe" ] ]
;;;   => "{ \"values\":[\"yes\", \"no\", \"maybe\"] }""
;;;
;;;   data-export:json-object [["label" "Dummy Survival"] ["units" "categorical"] ["values" ["Yes" "No" "Maybe"]]]
;;;   => "{ \"label\":\"Dummy Survival\", \"units\":\"categorical\", \"values\":[\"Yes\", \"No\", \"Maybe\"] }"
;;;
;;; WARNING: the array conversion is not robust, it sub-lists with three or more entries are arrays.
;;;
;;; Problem Examples:
;;;
;;;   data-export:json-object [ "ages" [ 24 32 ] ]
;;;   => "{ \"ages\":{ 24:\"24\":32 } }"
;;;
;;;   data-export:json-object [ "description" [ [ "size" 24 ] [ "length" 18 ] [ "color" "red" ] ] ]
;;;   => "{ \"description\":[[size 24], [length 18], [color red]] }"
;;;

to-report data-export:json-object [ key-value-pairs ]
  let str "{ "
  let q "\""
  let c ", "
  let last-key-value []
  let node item 0 key-value-pairs
  ifelse is-list? node
  [ foreach butlast key-value-pairs [
      set str ( word str ( data-export:jsonify-item item 0 ? ) ":" )
      ifelse is-list? item 1 ?
      [ ifelse (length item 1 ?) > 2
        [ set str ( word str ( data-export:json-array item 1 ? ) ) ]
        [ set str ( word str ( data-export:json-object item 1 ? ) ) ] ]
      [ set str ( word str data-export:jsonify-item item 1 ? c ) ] ]
    set last-key-value last key-value-pairs
    set str ( word str ( data-export:jsonify-item item 0 last-key-value ) ":" )
    ifelse is-list? item 1 last-key-value
    [ ifelse length item 1 last-key-value > 2
      [ report ( word str ( data-export:json-array item 1 last-key-value ) " }" ) ]
      [ report ( word str ( data-export:json-object item 1 last-key-value ) " }" ) ] ]
    [ report ( word str data-export:jsonify-item last last-key-value " }" ) ] ]
  ;; first item is not a list
  [ set str ( word str data-export:jsonify-item item 0 key-value-pairs ":" )
    ifelse is-list? item 1 key-value-pairs
    [ ifelse (length item 1 key-value-pairs) > 2
      [ report ( word str ( data-export:json-array item 1 key-value-pairs )  " }" ) ]
      [ report ( word str ( data-export:json-object item 1 key-value-pairs ) " }" ) ] ]
    [ report ( word str data-export:jsonify-item item 1 key-value-pairs " }" ) ] ]
end

to test-data-export:json-object
  let tests [
    [ [ "size" 24 ]                        "{ \"size\":24 }" ]
    [ [ "size" 24 ] [ "length" 18 ]        "{ \"size\":24, \"length\":18 }" ]
    [ [ "description" [ "size" 24 ] ]      "{ \"description\":{ \"size\":24 } }" ]
    [ [ "ages" [ 24 32 18 44 ] ]           "{ \"ages\":[24, 32, 18, 44] }" ]
    [ [ "values" [ "yes" "no" "maybe" ] ]  "{ \"values\":[\"yes\", \"no\", \"maybe\"] }" ]
    [ [ "label" "Dummy Survival"] ["units" "categorical"] ["values" ["Yes" "No" "Maybe" ] ]
                                           "{ \"label\":\"Dummy Survival\", \"units\":\"categorical\", \"values\":[\"Yes\", \"No\", \"Maybe\"] }" ] ]

   type "\n\n\ndata-export:json-object tests ...\n"
   foreach tests [
     let input butlast ?
     let expected last ?
     let result data-export:json-object input
     let pass expected = result
     ifelse pass
     [ type "\n       pass:" ]
     [ type "\n****** fail:" ]
     write input
     if not pass
     [ type   "\n   expected:"
       write expected ]
     type   "\n     actual:"
     write result
     type "\n"
   ]
   type "\n"
end

;;;
;;; *** data-export:json-array ***
;;;
;;; Converts flat lists to JSON arrays in string form.
;;;
;;; Example:
;;;
;;;   data-export:json-array [ 3.14 2.7 "no" "maybe" 10 ]
;;;   => "[3.14, 2.7, \"no\", \"maybe\", 10]"
;;;

to-report data-export:json-array [ items ]
  let str "["
  set str ( word str reduce [ ( word ?1 ", " ?2 ) ] ( map data-export:jsonify-item items ) )
  set str ( word str "]" )
  report str
end

;;;
;;; *** data-export:create-keypairs ***
;;;
;;; Combines two lists into one consisting of data pairs from each list.
;;;
;;; Examples:
;;;
;;;   data-export:create-keypairs [ 1 2 3 4 ] [ "a" "b" "c" "d" ]
;;;   =>  [[1 "a"] [2 "b"] [3 "c"] [4 "d"]]
;;;
;;;   data-export:create-keypairs [ "a" "b" "c" "d"] [ 1 2 3 4 ]
;;;   => [["a" 1] ["b" 2] ["c" 3] ["d" 4]]
;;;

to-report data-export:create-keypairs [ props vals ]
  let kv []
  let indices n-values length props [?]
  foreach indices
  [ set kv lput ( list ( item ? props ) ( item ? vals ) ) kv ]
  report kv
end

;;;
;;; *** data-export:indent-string ***
;;;
;;; Returns string of spaces [num] characters long.
;;;

to-report data-export:indent-string [num]
  report reduce word (n-values num [" "])
end

;;;
;;; *** data-export:jsonify-item ***
;;;
;;; Wraps quote characters around strings and returns them
;;; Other values are returned unchanged.
;;;

to-report data-export:jsonify-item [ val ]
  ifelse is-string? val
  [ report ( word "\"" val "\"" ) ]
  [ report val ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;; Testing for Generation of Valid JSON ;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; After getting the integration working it's imporyant to check to see if the
;;; generated JSON is valid.
;;;
;;; After running the model call the method data-export:make-model-data:
;;;
;;;   data-export:make-model-data
;;;
;;; This will update the global variable: data-export:model-data
;;;
;;; Now show data-export:model-data which contains the JSON data available for export:
;;;
;;;   print data-export:model-data
;;;
;;; After making changes test to see if the JSON data represent a valid JavaScript object.
;;;
;;; 1. Copy the string generated by running "show data-export:model-data" in the NetLogo observer.
;;; 2. Open a JavaScript console in a browser and execute the following code:
;;;
;;;   data = JSON.parse(<pasted-JSON-datastring-from-clipboard>)
;;;
;;; If this fails look at the error message and fix the NetLogo DataExport methods.
;;; If this succeeds inspect the newly created data object.
;;;
;;; Here's an example expanded in the browsers JavaScript console:
;;;
;;;   Object {description: Object, runs: Array[2]}
;;;     description: Object
;;;       computationalInputs: Array[5]
;;;       computationalOutputs: Array[2]
;;;       modelInformation: Object
;;;       studentInputs: Array[1]
;;;       timeSeriesData: Array[3]
;;;     runs: Array[2]
;;;       0: Object
;;;         timeSeriesData: Array[36]
;;;         computationalInputs: Array[5]
;;;         computationalOutputs: Array[2]
;;;         studentInputs: Array[1]
;;;       1: Object
;;;         timeSeriesData: Array[34]
;;;         computationalInputs: Array[5]
;;;         computationalOutputs: Array[2]
;;;         studentInputs: Array[1]
;;;